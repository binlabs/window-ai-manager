{"version":3,"file":"window-ai-manager.js","sources":["../src/polyfill.ts","../src/index.ts"],"sourcesContent":["class MockAITextSession implements AITextSession {\n    async prompt(input: string): Promise<string> {\n        return `Mock response to: ${input}`\n    }\n\n    async *promptStreaming(input: string): AsyncIterableIterator<string> {\n        yield `Mock streaming response to: ${input}`\n    }\n\n    destroy(): void {\n        console.log('Session destroyed')\n    }\n\n    clone(): AITextSession {\n        throw new Error('Clone not implemented')\n    }\n}\n\nclass MockAI implements AI {\n    async canCreateTextSession(): Promise<AIModelAvailability> {\n        return 'readily'\n    }\n\n    async createTextSession(options?: AITextSessionOptions): Promise<AITextSession> {\n        return new MockAITextSession()\n    }\n\n    async defaultTextSessionOptions(): Promise<AITextSessionOptions> {\n        return {\n            topK: 50,\n            temperature: 0.7,\n        }\n    }\n}\n\n// Only polyfill if the AI API is not already available\nif (!window.ai) {\n    ;(window as any).ai = new MockAI()\n}\n","import { marked } from 'marked'\nimport './polyfill'\n\n/**\n * Manages AI text sessions in the browser using the window.ai API.\n */\nclass WindowAIManager {\n    private sessions: Map<string, AITextSession>\n\n    constructor() {\n        this.sessions = new Map<string, AITextSession>()\n    }\n\n    /**\n     * Checks if a text session can be created.\n     * @returns {Promise<string>} One of \"readily\", \"after-download\", or \"no\".\n     */\n    async canCreateSession(): Promise<'readily' | 'after-download' | 'no'> {\n        const canCreate = await window.ai.canCreateTextSession()\n        return canCreate\n    }\n\n    /**\n     * Creates a new text session with the given sessionId.\n     * @param {string} sessionId - The unique identifier for the session.\n     * @throws {Error} If the model is not available on this device.\n     */\n    async createSession(sessionId: string): Promise<void> {\n        const canCreate = await this.canCreateSession()\n        if (canCreate === 'no') {\n            throw new Error('Cannot create session: model not available on this device.')\n        }\n        const session = await window.ai.createTextSession()\n        this.sessions.set(sessionId, session)\n    }\n\n    /**\n     * Sends a prompt to the specified session and returns the response.\n     * @param {string} sessionId - The unique identifier for the session.\n     * @param {string} text - The prompt text to send to the model.\n     * @returns {Promise<string>} The response from the model.\n     * @throws {Error} If the session with the given ID is not found.\n     */\n    async prompt(sessionId: string, text: string): Promise<string> {\n        const session = this.sessions.get(sessionId)\n        if (!session) {\n            throw new Error(`Session with ID ${sessionId} not found. Call createSession() first.`)\n        }\n        return await session.prompt(text)\n    }\n\n    /**\n     * Sends a streaming prompt to the specified session and processes the chunks received.\n     * @param {string} sessionId - The unique identifier for the session.\n     * @param {string} text - The prompt text to send to the model.\n     * @param {function} onChunkReceived - Callback function to handle each chunk received.\n     * @returns {Promise<string>} The final concatenated result from the model.\n     * @throws {Error} If the session with the given ID is not found.\n     */\n    async promptStreaming(sessionId: string, text: string, onChunkReceived: (chunk: string) => void): Promise<string> {\n        const session = this.sessions.get(sessionId)\n        if (!session) {\n            throw new Error(`Session with ID ${sessionId} not found. Call createSession() first.`)\n        }\n        const stream = session.promptStreaming(text)\n        let result = ''\n        let previousLength = 0\n        for await (const chunk of stream) {\n            const newContent = chunk.slice(previousLength)\n            onChunkReceived(newContent)\n            previousLength = chunk.length\n            result += newContent\n        }\n        return result\n    }\n\n    /**\n     * Destroys the specified session and removes it from the map.\n     * @param {string} sessionId - The unique identifier for the session.\n     * @throws {Error} If the session with the given ID is not found.\n     */\n    async destroySession(sessionId: string): Promise<void> {\n        const session = this.sessions.get(sessionId)\n        if (session) {\n            session.destroy()\n            this.sessions.delete(sessionId)\n        } else {\n            throw new Error(`Session with ID ${sessionId} not found.`)\n        }\n    }\n\n    /**\n     * Destroys all active sessions and clears the map.\n     */\n    async destroyAllSessions(): Promise<void> {\n        for (const [_sessionId, session] of this.sessions) {\n            session.destroy()\n        }\n        this.sessions.clear()\n    }\n\n    /**\n     * Renders markdown text to HTML.\n     * @param {string} markdown - The markdown text to render.\n     * @returns {string} The rendered HTML.\n     */\n    renderMarkdown(markdown: string): string | Promise<string> {\n        return marked(markdown)\n    }\n}\n\nexport default WindowAIManager\n"],"names":["marked"],"mappings":"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"}